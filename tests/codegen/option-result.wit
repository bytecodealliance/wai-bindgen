interface option-result {
	record empty {}
	record o-one {
		a: option<bool>,
	}

	record o-nested {
		a: option<option<o-one>>,
	}
	
	type o1 = option<>
	type o2 = option<empty>
	type o3 = option<o-nested>
	type o4 = option<option<o-nested>>

	type r1 = result
	type r2 = result<_ empty>
	type r3 = result<empty>
	type r4 = result<empty, empty>
	type r5 = result<option<>, o1>
	type r6 = result<option<option<>>, o2>
	type r7 = result<option<option<>>, o4>


	type o5 = option<result>
	type o6 = option<result<option<result>>>


	func o1-arg(x: o1)
	func o1-result() -> o1

	func o2-arg(x: o2)
	func o2-result() -> o2

	func o3-arg(x: o3)
	func o3-result() -> o3

	func o4-arg(x: o4)
	func o4-result() -> o4

	func o5-arg(x: o5)
	func o5-result() -> o5

	func o6-arg(x: o6)
	func o6-result() -> o6

	func r1-arg(x: r1)
	func r1-result() -> r1

	func r2-arg(x: r2)
	func r2-result() -> r2

	func r3-arg(x: r3)
	func r3-result() -> r3

	func r4-arg(x: r4)
	func r4-result() -> r4

	func r5-arg(x: r5)
	func r5-result() -> r5

	func r6-arg(x: r6)
	func r6-result() -> r6

	func r7-arg(x: r7)
	func r7-result() -> r7

	func multi(x: r7, y: r7) -> (a: r7, b:r7, c: r7)
	func multi-option(x: r7, y: r7) -> option<tuple<r7, r7>>
}

default world my-world {
	import imports: self.variants
	export exports: self.variants
}
  